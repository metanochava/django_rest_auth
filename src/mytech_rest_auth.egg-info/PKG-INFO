Metadata-Version: 2.4
Name: mytech_rest_auth
Version: 1.1.11
Summary: App de autenticaÃ§Ã£o e gestÃ£o de entidades para Django REST Framework
Author-email: Dias Metano Salvador Chavana <metanochava@gmail.com>
License: MIT License
        
        Copyright (c) 2025 Metano Chavana
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        
Project-URL: Homepage, https://github.com/metanochava/django_rest_auth
Project-URL: Repository, https://github.com/metanochava/django_rest_auth
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: Django==5.2.10
Requires-Dist: djangorestframework==3.16.1
Requires-Dist: djangorestframework_simplejwt==5.5.1
Requires-Dist: rest-framework-simplejwt==0.0.2
Requires-Dist: drf-writable-nested==0.7.2
Requires-Dist: Pillow
Requires-Dist: pyotp
Requires-Dist: qrcode[pil]==7.4
Requires-Dist: python-barcode==0.15.1
Dynamic: license-file

## ViewSet Rule

All concrete ViewSets MUST define a base queryset.

The BaseViewSet only applies multi-tenant filters and permissions,
it does not define the base queryset.

Example:
```bash 
    class PessoaViewSet(BaseViewSet):
        queryset = Pessoa.objects.select_related('user', 'endereco')

```

# Translate (Project Rule)

All text returned by the API MUST be translated using the Translate class.

Frontend applications must not translate text.

Example:

```bash
python
from django_rest_auth.classes.Translate import Translate

return Response({
    'alert_error': Translate.tdc(request, 'Permission denied')
}, status=403)
```

# CoreFileMiddleware

This middleware protects access to media files.

Only requests with a valid token are allowed.

## Behavior
- Intercepts requests to MEDIA_URL
- Validates token from querystring
- Returns translated error messages

## Example
/media/document.pdf?token=XYZ

## Unauthorized response
```json
{
  "alert_error": "Nao autorizado"
}
```
# CoreMiddleware

Este middleware controla o acesso Ã s rotas da API.

O acesso Ã© permitido apenas para:
- Frontends autorizados (FEK + FEP)
- EndereÃ§os IP autorizados

## Comportamento
- Ignora URLs pÃºblicas definidas em `settings.AUTH_URL`
- Valida headers FEK e FEP
- Caso invÃ¡lido, retorna erro traduzido via `Translate`

## Headers esperados
FEK: Frontend Key  
FEP: Frontend Password  

## Resposta nÃ£o autorizada
```json
{
  "code": 10001,
  "alert_error": "NÃ£o autorizado"
}
```

# File Token Configuration

A biblioteca suporta dois tipos de token para acesso a ficheiros:

- ğŸ” Token permanente (nÃ£o expira)
- â±ï¸ Token temporÃ¡rio (com TTL)

## Settings
```python
DJANGO_REST_AUTH = {
    'FILE_TOKEN': {
        'ENABLE_TEMPORARY': True,
        'TEMP_TTL': 300,
        'ENABLE_PERMANENT': True,
    },
    'REQUIRE_FE_CREDENTIALS': True,
    'TENANT_HEADERS': {
        'ENTIDADE': 'E',
        'SUCURSAL': 'S',
        'GRUPO': 'G',
        'TIPO_ENTIDADE': 'ET',
        'LANG': 'L',
    }
}
```

## Email Templates

A biblioteca permite substituir os templates de email via settings.

### Exemplo:

```python
DJANGO_REST_AUTH = {
    'EMAIL_TEMPLATES': {
        'REGISTER_CONFIRM': 'emails/confirmacao.html',
        'PASSWORD_RESET': 'emails/reset.html',
        'GENERIC_RESET': 'emails/generico.html',
    }
}

E no settings.py:

TEMPLATES[0]['DIRS'] += [BASE_DIR / 'templates']

No projeto final:

project/
â””â”€â”€ templates/
    â””â”€â”€ emails/
        â”œâ”€â”€ meu_confirmacao.html
        â”œâ”€â”€ meu_reset.html
        â””â”€â”€ meu_generico.html
```


```bash 

ğŸ“˜ PADRÃƒO DE PERISSÃ•ES â€“ FRAMEWORK MULTI-TENANT

Este projeto implementa um sistema de permissÃµes centralizado, multi-tenant e orientado a APIs, baseado em:

Django Permissions (auth_permission)

Groups (auth_group)

Contexto dinÃ¢mico via headers

ValidaÃ§Ã£o automÃ¡tica no BaseViewSet

Uma Ãºnica query por request (alta performance)

ğŸ§± Conceitos Fundamentais
ğŸ”¹ Tipo de Entidade

ClassificaÃ§Ã£o da organizaÃ§Ã£o (ex: ClÃ­nica, Escola, Empresa).

ğŸ”¹ Entidade

OrganizaÃ§Ã£o principal (ex: ClÃ­nica ABC).

ğŸ”¹ Sucursal

Unidade da entidade (ex: Filial Luanda).

ğŸ”¹ Grupo

Papel do utilizador numa sucursal (ex: Admin, RH, MÃ©dico).

ğŸ”¹ Utilizador

Pode pertencer a:

mÃºltiplas Entidades

mÃºltiplas Sucursais

mÃºltiplos Grupos

ğŸ§­ Contexto ObrigatÃ³rio (Headers)

Todo request autenticado DEVE enviar os headers abaixo:

Header	DescriÃ§Ã£o
ET	ID do Tipo de Entidade
E	ID da Entidade
S	ID da Sucursal
G	ID do Grupo
L	Idioma (opcional)

ğŸ“Œ Sem estes headers, o acesso Ã© negado.

ğŸ” Modelo de PermissÃµes (PadrÃ£o)

O sistema segue o padrÃ£o Django com extensÃ£o para list.

CRUD padrÃ£o
Action (DRF)	PermissÃ£o
list	list_<model>
retrieve	view_<model>
create	add_<model>
update	change_<model>
partial_update	change_<model>
destroy	delete_<model>

ğŸ“Œ <model> Ã© o nome do model em minÃºsculas.

Exemplo (Colaborador)
list_colaborador
view_colaborador
add_colaborador
change_colaborador
delete_colaborador

âš™ï¸ PermissÃµes AutomÃ¡ticas

ApÃ³s cada migrate, o sistema cria automaticamente:

list_<model>

Apenas para os apps definidos em:

settings.MY_APPS


âœ”ï¸ NÃ£o hÃ¡ risco de duplicaÃ§Ã£o
âœ”ï¸ Usa get_or_create()
âœ”ï¸ (codename, content_type) Ã© Ãºnico no Django

âœ¨ PermissÃµes Customizadas no Model

Models podem definir permissÃµes adicionais:

class Colaborador(models.Model):
    class Meta:
        permissions = (
            ('icon', 'Menu Icon'),
            ('list_contauser', 'Can list Conta User'),
        )


Estas permissÃµes:

sÃ£o criadas pelo Django

podem ser atribuÃ­das a grupos

podem ser usadas nas views

ğŸ§  VerificaÃ§Ã£o de PermissÃµes

Toda a verificaÃ§Ã£o acontece via:

isPermited(request=request, role=[codename])


Internamente, o sistema valida numa Ãºnica query:

user âˆˆ grupo

grupo âˆˆ sucursal

sucursal âˆˆ entidade

entidade âˆˆ tipo_entidade

grupo possui a permissÃ£o solicitada

Se qualquer condiÃ§Ã£o falhar â†’ acesso negado.

ğŸ§© BaseViewSet (AutomÃ¡tico)

Todas as APIs devem herdar de:

django_rest_auth.views.BaseViewSet

O que o BaseViewSet faz

âœ”ï¸ valida permissÃµes automaticamente

âœ”ï¸ injeta contexto (entidade_id, sucursal_id, etc.)

âœ”ï¸ filtra queryset por tenant

âœ”ï¸ implementa soft delete

âœ”ï¸ nÃ£o usa decorators

ğŸ” Mapeamento de PermissÃµes por Action
ğŸ”¹ Mapa padrÃ£o (interno)
permission_action_map = {
    'list': 'list',
    'retrieve': 'view',
    'create': 'add',
    'update': 'change',
    'partial_update': 'change',
    'destroy': 'delete',
}

âœï¸ method_permission (Override por ViewSet)

Cada ViewSet pode estender ou sobrescrever permissÃµes usando:

method_permission = {}

Prioridade
method_permission  >  permission_action_map

ğŸ“Œ Exemplos PrÃ¡ticos
âœ”ï¸ ViewSet simples (CRUD padrÃ£o)
class ColaboradorViewSet(BaseViewSet):
    queryset = Colaborador.objects.all()
    serializer_class = ColaboradorSerializer


PermissÃµes usadas automaticamente:

list_colaborador
add_colaborador
change_colaborador
delete_colaborador

âœ”ï¸ Action custom (bulk_create)
class ColaboradorViewSet(BaseViewSet):
    queryset = Colaborador.objects.all()
    serializer_class = ColaboradorSerializer

    method_permission = {
        'bulk_create': 'add',
    }

    @action(detail=False, methods=['post'])
    def bulk_create(self, request):
        ...


PermissÃ£o exigida:

add_colaborador

âœ”ï¸ Sobrescrever permissÃ£o de action padrÃ£o
class ColaboradorViewSet(BaseViewSet):
    method_permission = {
        'list': 'view',
    }


Agora o list exige:

view_colaborador

ğŸš« O que NÃƒO fazer

âŒ Criar views sem herdar de BaseViewSet
âŒ Ignorar headers de contexto
âŒ Usar decorators de permissÃ£o em views
âŒ Implementar lÃ³gica de tenant fora do core

âš¡ Performance

âœ”ï¸ 1 query por request para permissÃµes

âœ”ï¸ Usa exists() + JOIN

âœ”ï¸ Sem carregar objetos em memÃ³ria

âœ”ï¸ Escala bem com muitos utilizadores

ğŸ ConclusÃ£o

Este padrÃ£o fornece:

ğŸ”’ SeguranÃ§a forte

âš¡ Alta performance

ğŸ” ReutilizaÃ§Ã£o total

ğŸ§± Arquitetura de framework

ğŸ“¦ Preparado para mÃºltiplos domÃ­nios (RH, ClÃ­nica, Escola, etc.)

Se quiseres, posso:

gerar isto em Markdown final

criar um diagrama de fluxo

documentar BaseRHViewSet

criar exemplos reais do RH

Ã‰ sÃ³ dizer ğŸš€

    INSTALLED_APPS = [
        'corsheaders',
        ...
    ]

    MIDDLEWARE = [
        'corsheaders.middleware.CorsMiddleware',
        'django.middleware.common.CommonMiddleware',
        ...
    ]

    CORS_ALLOWED_ORIGINS = [
        "http://84.247.162.222:9000",
    ]

    CORS_ALLOW_CREDENTIALS = True

    from corsheaders.defaults import default_headers
    CORS_ALLOW_HEADERS = list(default_headers) + [
        "fek",
        "fep",
    ]



```




